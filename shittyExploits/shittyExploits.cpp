#include <thread>
#include <chrono>
#include <memory>
#include <iostream>
#include <api/api.h>
#include "shittyExploits.h"

using namespace std;
using namespace std::chrono;
namespace api = wolverindev::ts;

std::string pluginId;
struct TS3Functions functions{};
struct wolverindev::ts::ApiFunctions hook_functions{};

auto local_hook_deleter = [](api::Hook* instance) {
	if(instance && hook_functions.unregisterHook)
		hook_functions.unregisterHook(instance);
	delete instance;
};
unique_ptr<api::Hook, decltype(local_hook_deleter)> local_hook_test(nullptr, local_hook_deleter);


void ts3plugin_freeMemory(void *data) {
	if (data) free(data);
}

void ts3plugin_setFunctionPointers(const struct TS3Functions funcs) {
	functions = funcs;
}

void ts3plugin_registerPluginID(const char *id) {
	pluginId = id;
}

const char *ts3plugin_name() {
	return "Hook [shittyExploits]";
}

const char *ts3plugin_version() {
	return "1.0";
}

int ts3plugin_apiVersion() {
	return 22;
}

const char *ts3plugin_author() {
	return "exp111";
}

const char *ts3plugin_description() {
	return "A example plugin which uses the hook api";
}

int ts3plugin_init() { 
	//If we get initialized after the hook we dont recive the hook_initialized event so we have to notify the hook that we're alive!
	//Defined within the API
	trigger_plugin_loaded(); 
	return 0;
}

void ts3plugin_shutdown() {
	if(local_hook_test) hook_functions.unregisterHook(local_hook_test.get());
	hook_functions = {};
}

void onPacketOut(api::SCHId schId, api::CommandPacket* command, bool &canceled)
{
	string cmd = command->data();
	// Self Kick
	if (cmd == "sendtextmessage targetmode=2 msg=~clientinit")
	{
		command->data("clientinit");
		return;
	}

	if (cmd.find("clientinit ") != string::npos)
	{
		if (cmd.back() != ' ')
			cmd += ' ';

		// Is Recording
		if (cmd.find("client_is_recording") == string::npos)
			cmd += "client_is_recording=1 ";

		// Description
		if (cmd.find("client_description") == string::npos)
			cmd += "client_description=Hello ";

		// Is Talker
		if (cmd.find("client_is_talker") == string::npos)
			cmd += "client_is_talker=1 ";

		// Is Channel Commander
		if (cmd.find("client_is_channel_commander") == string::npos)
			cmd += "client_is_channel_commander=1 ";

		command->data(cmd);
	}
}

void onPacketIn(api::SCHId schId, api::CommandPacket* command, bool &canceled)
{

}

int hook_initialized(const wolverindev::ts::ApiFunctions fn) 
{
	hook_functions = fn;

	local_hook_test.reset(new api::Hook());
	local_hook_test->activated = [](){ return true; };
	local_hook_test->on_packet_out = &onPacketOut;
	local_hook_test->on_packet_in = &onPacketIn;
	
	hook_functions.registerHook(local_hook_test.get());
	return 0;
}

void hook_finalized() 
{
	if(local_hook_test) hook_functions.unregisterHook(local_hook_test.get());
	hook_functions = {};
}